        .text
        .globl main
main:
        subu $sp, $sp, 32       # スタックフレームは32バイト長
        sw $ra, 20($sp)         # 戻りアドレスを退避
        sw $fp, 16($sp)         # 古いフレームポインタを退避
        addu $fp, $sp, 32       # 新しいフレーム・ポインタを設定

        li $a0, 10              # 第一引数 10 を$a0 へ入れて
        jal square              # square を呼び出す。

        move $a0, $v0           # square が返した値を$a0 へ
        li $v0, 1               # システムコールprint_int の番号 1
        syscall                 # システムコールで印刷

        lw $ra, 20($sp)         # 戻りアドレスを復元
        lw $fp, 16($sp)         # フレームポインタを復元
        addu $sp, $sp, 32       # スタックフレームを巻き上げる(縮めて元に戻す)
        jr $ra                  # main を呼んだ呼出し側へ戻る

square:                         # ここから square 関数
        subu $sp, $sp, 32       # スタックフレームは最低32バイト長
        sw $ra, 20($sp)         # 戻りアドレスを退避
        sw $fp, 16($sp)         # フレームポインタを退避
        addu $fp, $sp, 32       # フレームポインタを設定

        mul $v0, $a0, $a0       # $a0 の内容 × $a0 の内容 を $v0 に入れる。
                                # $a0 には引数 n が入っていたので、
                                # n * n を $v0 に入れたことになる。
                                # 本来、かけ算の結果は HI と LO に入るのだが、
                                # mul を使うと、LO に入ったもの(積の下位32ビット)を、
                                # 通常のレジスタに入れてくれる。 (mul は疑似命令。)

        # ここから、リターンの処理
        lw $ra, 20($sp)         # 戻りアドレスを復元
        lw $fp, 16($sp)         # フレームポインタを復元
        addu $sp, $sp, 32       # スタック・フレームを巻き上げる
        jr $ra                  # 呼び出し元へ戻る